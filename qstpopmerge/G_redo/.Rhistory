demo()
Hershey
> x = seq(1,10) # set the x-axis values
> b = 3 # set the intercept
> m = 0.5 # set the slope
> y = m*x + b
> plot(x,y) # plot paired coordinates. This only works if x and y are the same length!
> plot(y~x) # plot y as a function of x
1+1
print('Hello world!') # why quotes? why parenthesis? what is the 'argument' for this function?
help(print) # now why aren't there quotes?
mixed.data <- c(1,2,'a',7)
typeof(mixed.data) # it's a character, and now all the numbers are in quotes!
number.set<-c(number.set, 11, 12, 13) # concatenate the object with itself
number.set<-c(number.set, 11, 12, 13) # concatenate the object with itself
pasted.data <- paste(1,2,3)
# This function works like c(), but puts all of the arguments into one element
length(pasted.data)
rep.data <- rep(10,5)
?rep.data
?rep
x = seq(1,10) # set the x-axis values
b = 3 # set the intercept
m = 0.5 # set the slope
y = m*x + b
plot(x,y) # plot paired coordinates. This only works if x and y are the same length!
plot(y~x) # plot y as a function of x
getwd() # This returns the path to the working directory. This is where R will save your outputs.
library(qtl)
data(hyper)
summary(hyper)
plot.missing(hyper, reorder = TRUE)
hyper <- calc.errorlod(hyper, error.prob=0.01)
top.errorlod(hyper)
plot.geno(hyper, chr=1, ind=c(117:119,137:139,157:184))
hyper <- calc.genoprob(hyper, step=2, error.prob=0.01)
## Scan to get interval mapping (em) and Haley-Knott (hk) LOD curves.
out.em <- scanone(hyper)
out.hk <- scanone(hyper, method="hk")
## Summaries: max per chromosome above threshold.
summary(out.em, threshold=3)
summary(out.hk, threshold=3)
plot(out.em, chr = c(1,4,6,15))
plot(out.hk, chr = c(1,4,6,15), add = TRUE, lty = 2)
## Permutation thresholds (much faster with hk).
operm.hk <- scanone(hyper, method="hk", n.perm=1000)
summary(operm.hk, alpha=c(0.01,0.05))
abline(h = summary(operm.hk, alpha=c(0.01,0.05)), lty = 3)
summary(out.hk, perms=operm.hk, alpha=0.05, pvalues=TRUE)
## Calculate genoprob on coarser grid (faster) for 2-D scan.
hyper <- calc.genoprob(hyper, step=5, error.prob=0.01)
out2.hk <- scantwo(hyper, method="hk")
summary(out2.hk, thresholds=c(6.0, 4.7, 4.4, 4.7, 2.6))
summary(out2.hk, thresholds=c(6.0, 4.7, 4.4, 4.7, 2.6), what = "int")
plot(out2.hk, chr=c(1,4,6,15))
hyper <- sim.geno(hyper, step=2, n.draws=16, error.prob=0.01)
qtl <- makeqtl(hyper, chr = c(1, 1, 4, 6, 15), pos = c(50, 76, 30, 70, 20))
my.formula <- y ~ Q1 + Q2 + Q3 + Q4 + Q5 + Q4:Q5
out.fitqtl <- fitqtl(hyper, pheno.col = 1, qtl, formula=my.formula)
summary(out.fitqtl)
hyper <- sim.geno(hyper, step=2, n.draws=16, error.prob=0.01)
effectplot(hyper, pheno.col = 1, mname1 = "D1Mit334")
effectplot(hyper, pheno.col = 1, mname1 = "D4Mit164")
markers <- find.marker(hyper, chr = c(6,15), pos = c(70,20))
markers
effectplot(hyper, pheno.col = 1, mname1 = markers[1], mname2 = markers[2])
effectplot(hyper, pheno.col = 1, mname1 = markers[2], mname2 = markers[1])
effectplot(hyper, pheno.col = 1, mname1 = "D1Mit334")
effectplot(hyper, pheno.col = 1, mname1 = "D4Mit164")
effectplot(hyper, pheno.col = 1, mname1 = markers[1], mname2 = markers[2])
effectplot(hyper, pheno.col = 1, mname1 = markers[2], mname2 = markers[1])
plot.pxg(hyper, "D1Mit334")
plot.pxg(hyper, "D4Mit164")
plot.pxg(hyper, markers)
markers
library(qtl)
library(qtl)
install.packages("asreml")
ASREML_LICENSE_FILE=/Library/Frameworks/R.framework/Versions/2.12/Resources/lib/asreml.lic
library(asreml)
install.packages("PopGenReport")
install.packages("PopGenReport", repos='http://cran.rstudio.com/')
install.packages("PopGenReport")
library(driftsel)
library(RAFM)
load("~/Dropbox/QSTFST/maps/mappintime.RData")
setwd("~/Dropbox/QSTFST/qstpopmerge/G_redo")
# library(expm) # for covariance matrix decomposition
library(KernSmooth) # for package neutrality test.r
library(corpcor) # for package neutrality test.r
library(MASS) # for package neutrality test.r
source("~/Dropbox/QSTFST/qstpopmerge/package neutrality test.r")
box.scale.na <- read.csv("box.scale.na.csv")
box.scale <- read.csv("box.scale.csv")
names(box.scale.na) <- c("Id", "Pop", "Dam", "CorollaWidth", "CorollaLength", "PetalLength",
"Color", "NectarAmt", "NectarConc", "Root", "Fdate")
names(box.scale) <- c("Id","Pop","Dam","CorollaWidth","CorollaLength","PetalLength",
"Color","NectarAmt","NectarConc","Root","Fdate")
#####################
# G and D matricies using MANOVA code from B
dam.mean <- aggregate(box.scale[,4:9], list(box.scale$Dam), mean, na.rm=T)
dam.mean
pop.dam <- unique(box.scale[,c(2,3)])
trait.mean <- merge(pop.dam, dam.mean, by.y="Group.1", by.x="Dam")
write.csv(trait.mean, "trait.mean.csv")
tm <- read.csv("trait.mean.csv")
head(tm)
# data <- as.matrix(tm[,4:9])
# factor <- as.matrix(tm[,3])
#######testing
head(tm)
test.data <- cbind(tm$X, tm$Pop, tm$Dam, tm[,4:9])
head(test.data)
names(test.data)
names(test.data) <- c("id", "pop","fam","CorW","CorL","PetL","Col","NecA","NecC")
head(test.data)
## for test.data
n=dim(test.data)[2]-3;nn=table(test.data$pop);nbpop=length(nn);
traits=names(test.data[-c(1:3)]);
effect=paste(traits,collapse=",")
form=as.formula(paste("cbind(",effect,")~factor(pop)",sep="")) #automated formula for the manova
manov=summary(manova(form,data=test.data))                   #do the manova
SSb=manov$SS$"factor(pop)";                             #between pop Sum Squares (SS)
SSw=manov$SS$Residuals;                                 #within pop SS
dfb=manov$stats[1,1];dfw=manov$stats[2,1];              #df between/within pops
nf=mean(nn)-1/nbpop*((mean(nn^2)-mean(nn)^2)/mean(nn)); #compute the equivalent df with unbalanced designs
MSw=SSw/dfw;MSb=SSb/dfb;                                #compute the corresponding Mean Square matrices
Gw=MSw;Gb=(MSb-Gw)/nf;                                  #compute the corresponding G matrices
DF=c(dfw,dfb);G=list(Gw,Gb);MS=list(MSw,MSb);           #create the inputs for k.prop()
# Correlations
Gwcor<- cov2cor(Gw)
Gbcor<- cov2cor(Gb)
Gwcor
Gbcor
###############
# bending test
# Here is a function that I use for symmetric matrices:
# https://stat.ethz.ch/pipermail/r-help/2003-December/042964.html
make.positive.definite <-
function(x, tol=1e-6) {
eig <- eigen(x, symmetric=TRUE)
rtol <- tol * eig$values[1]
if(min(eig$values) < rtol) {
vals <- eig$values
vals[vals < rtol] <- rtol
srev <- eig$vectors %*% (vals * t(eig$vectors))
dimnames(srev) <- dimnames(x)
return(srev)
} else {
return(x)
}
}
nGb <- make.positive.definite(Gb)
# Correlations
Gwcor<- cov2cor(Gw)
nGbcor<- cov2cor(nGb)
Gwcor
nGbcor
######### proportionality testing
#rho_st from test between G matrices
testG=k.prop(DF,G)
paste("rho_P (population) =",signif(testG$rho[[2]],2))
print("95% CI for rho_P :");signif(testG$CI[[2]],2)
# same but with pos. def Gb
Gpos=list(Gw,nGb)
testG=k.prop(DF,Gpos)
paste("rho_P (population) =",signif(testG$rho[[2]],2))
print("95% CI for rho_P :");signif(testG$CI[[2]],2)
#p-values from test between MS matrices
testMS=k.prop(DF,MS);
paste("pBartlett=",signif(testMS$pt1,3),"pChiâ‰¤=",signif(testMS$pX,3))
# Read Martin's script (Check dependencies first: MASS, KernSmooth, corpcor)
##########################
# decomposition of Gw, nGb
gw.out <- princomp(covmat=Gw)
names(gw.out)
gw.out$loadings
summary(gw.out)
plot(gw.out) #scree plot
gb.out <- princomp(covmat=nGb)
names(gb.out)
gb.out$loadings
summary(gb.out)
plot(gb.out) #scree plot
par(mfrow=c(2,2), mar=c(2.5,3,3,3),oma = c(1, 1, 4, 1))
barplot(eigvw[,1],names=name, main=expression("G"[W]*" PC1: 39.3%"), col=color, cex.names=1, cex.main = 1.3)
barplot(eigvw[,2],names=name, main=expression("G"[W]*" PC2: 22.2%"), col=color, cex.names=1, cex.main = 1.3)
barplot(eigvb[,1],names=name, main=expression("G"[B]*" PC1: 90.1%"), col=color, cex.names=1, cex.main = 1.3)
barplot(eigvb[,2],names=name, main=expression("G"[B]*" PC2: 9.2%"), col=color, cex.names=1, cex.main = 1.3)
mtext("PC trait toadings for G-within and G-between", outer = TRUE, cex = 1.5)
eigb <- eigen(nGb)
eigvb <- eigb$vectors
abs(eigvb[,1])/sum(abs(eigvb[,1]))
abs(eigvb[,1])/max(abs(eigvb[,1]))
cumsum(eigb$values/sum(eigb$values))
eigb$values/sum(eigb$values)
#Gw
eigw <- eigen(Gw)
eigvw <- eigw$vectors
abs(eigvw[,1])/sum(abs(eigvw[,1]))
abs(eigvw[,1])/max(abs(eigvw[,1]))
cumsum(eigw$values/sum(eigw$values))
eigw$values/sum(eigw$values)
nGb
par(mfrow=c(2,2), mar=c(2.5,3,3,3),oma = c(1, 1, 4, 1))
barplot(eigvw[,1],names=name, main=expression("G"[W]*" PC1: 39.3%"), col=color, cex.names=1, cex.main = 1.3)
barplot(eigvw[,2],names=name, main=expression("G"[W]*" PC2: 22.2%"), col=color, cex.names=1, cex.main = 1.3)
barplot(eigvb[,1],names=name, main=expression("G"[B]*" PC1: 90.1%"), col=color, cex.names=1, cex.main = 1.3)
barplot(eigvb[,2],names=name, main=expression("G"[B]*" PC2: 9.2%"), col=color, cex.names=1, cex.main = 1.3)
mtext("PC trait toadings for G-within and G-between", outer = TRUE, cex = 1.5)
color <- c("darkred", "darkred", "darkred", "darkred", "yellow", "yellow")
name <- c("CW","CL","PL","Col","NV","NC")
par(mfrow=c(2,2), mar=c(2.5,3,3,3),oma = c(1, 1, 4, 1))
barplot(eigvw[,1],names=name, main=expression("G"[W]*" PC1: 39.3%"), col=color, cex.names=1, cex.main = 1.3)
barplot(eigvw[,2],names=name, main=expression("G"[W]*" PC2: 22.2%"), col=color, cex.names=1, cex.main = 1.3)
barplot(eigvb[,1],names=name, main=expression("G"[B]*" PC1: 90.1%"), col=color, cex.names=1, cex.main = 1.3)
barplot(eigvb[,2],names=name, main=expression("G"[B]*" PC2: 9.2%"), col=color, cex.names=1, cex.main = 1.3)
mtext("PC trait toadings for G-within and G-between", outer = TRUE, cex = 1.5)
### sub-script in plot lables
pdf("G_loadings_noabs.pdf", width=8, height=6)
par(mfrow=c(2,2), mar=c(2.5,3,3,3),oma = c(1, 1, 4, 1))
barplot(eigvw[,1],names=name, main=expression("G"[W]*" PC1: 39.3%"), col=color, cex.names=1, cex.main = 1.3)
barplot(eigvw[,2],names=name, main=expression("G"[W]*" PC2: 22.2%"), col=color, cex.names=1, cex.main = 1.3)
barplot(eigvb[,1],names=name, main=expression("G"[B]*" PC1: 90.1%"), col=color, cex.names=1, cex.main = 1.3)
barplot(eigvb[,2],names=name, main=expression("G"[B]*" PC2: 9.2%"), col=color, cex.names=1, cex.main = 1.3)
mtext("PC trait toadings for G-within and G-between", outer = TRUE, cex = 1.5)
dev.off()
