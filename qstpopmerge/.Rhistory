demo()
Hershey
> x = seq(1,10) # set the x-axis values
> b = 3 # set the intercept
> m = 0.5 # set the slope
> y = m*x + b
> plot(x,y) # plot paired coordinates. This only works if x and y are the same length!
> plot(y~x) # plot y as a function of x
1+1
print('Hello world!') # why quotes? why parenthesis? what is the 'argument' for this function?
help(print) # now why aren't there quotes?
mixed.data <- c(1,2,'a',7)
typeof(mixed.data) # it's a character, and now all the numbers are in quotes!
number.set<-c(number.set, 11, 12, 13) # concatenate the object with itself
number.set<-c(number.set, 11, 12, 13) # concatenate the object with itself
pasted.data <- paste(1,2,3)
# This function works like c(), but puts all of the arguments into one element
length(pasted.data)
rep.data <- rep(10,5)
?rep.data
?rep
x = seq(1,10) # set the x-axis values
b = 3 # set the intercept
m = 0.5 # set the slope
y = m*x + b
plot(x,y) # plot paired coordinates. This only works if x and y are the same length!
plot(y~x) # plot y as a function of x
getwd() # This returns the path to the working directory. This is where R will save your outputs.
library(qtl)
data(hyper)
summary(hyper)
plot.missing(hyper, reorder = TRUE)
hyper <- calc.errorlod(hyper, error.prob=0.01)
top.errorlod(hyper)
plot.geno(hyper, chr=1, ind=c(117:119,137:139,157:184))
hyper <- calc.genoprob(hyper, step=2, error.prob=0.01)
## Scan to get interval mapping (em) and Haley-Knott (hk) LOD curves.
out.em <- scanone(hyper)
out.hk <- scanone(hyper, method="hk")
## Summaries: max per chromosome above threshold.
summary(out.em, threshold=3)
summary(out.hk, threshold=3)
plot(out.em, chr = c(1,4,6,15))
plot(out.hk, chr = c(1,4,6,15), add = TRUE, lty = 2)
## Permutation thresholds (much faster with hk).
operm.hk <- scanone(hyper, method="hk", n.perm=1000)
summary(operm.hk, alpha=c(0.01,0.05))
abline(h = summary(operm.hk, alpha=c(0.01,0.05)), lty = 3)
summary(out.hk, perms=operm.hk, alpha=0.05, pvalues=TRUE)
## Calculate genoprob on coarser grid (faster) for 2-D scan.
hyper <- calc.genoprob(hyper, step=5, error.prob=0.01)
out2.hk <- scantwo(hyper, method="hk")
summary(out2.hk, thresholds=c(6.0, 4.7, 4.4, 4.7, 2.6))
summary(out2.hk, thresholds=c(6.0, 4.7, 4.4, 4.7, 2.6), what = "int")
plot(out2.hk, chr=c(1,4,6,15))
hyper <- sim.geno(hyper, step=2, n.draws=16, error.prob=0.01)
qtl <- makeqtl(hyper, chr = c(1, 1, 4, 6, 15), pos = c(50, 76, 30, 70, 20))
my.formula <- y ~ Q1 + Q2 + Q3 + Q4 + Q5 + Q4:Q5
out.fitqtl <- fitqtl(hyper, pheno.col = 1, qtl, formula=my.formula)
summary(out.fitqtl)
hyper <- sim.geno(hyper, step=2, n.draws=16, error.prob=0.01)
effectplot(hyper, pheno.col = 1, mname1 = "D1Mit334")
effectplot(hyper, pheno.col = 1, mname1 = "D4Mit164")
markers <- find.marker(hyper, chr = c(6,15), pos = c(70,20))
markers
effectplot(hyper, pheno.col = 1, mname1 = markers[1], mname2 = markers[2])
effectplot(hyper, pheno.col = 1, mname1 = markers[2], mname2 = markers[1])
effectplot(hyper, pheno.col = 1, mname1 = "D1Mit334")
effectplot(hyper, pheno.col = 1, mname1 = "D4Mit164")
effectplot(hyper, pheno.col = 1, mname1 = markers[1], mname2 = markers[2])
effectplot(hyper, pheno.col = 1, mname1 = markers[2], mname2 = markers[1])
plot.pxg(hyper, "D1Mit334")
plot.pxg(hyper, "D4Mit164")
plot.pxg(hyper, markers)
markers
library(qtl)
library(qtl)
install.packages("asreml")
ASREML_LICENSE_FILE=/Library/Frameworks/R.framework/Versions/2.12/Resources/lib/asreml.lic
library(asreml)
install.packages("PopGenReport")
install.packages("PopGenReport", repos='http://cran.rstudio.com/')
install.packages("PopGenReport")
library(driftsel)
library(RAFM)
## install.packages("devtools")
## install_github("kjgilbert/QstFstComp")
library(devtools)
library(QstFstComp)
library(psych) # for pairs.panels
library(car) # for dataEllipse
library(MASS) # for boxcox transformation
library(adegenet)
library(hierfstat)
library(pegas)
setwd("~/Dropbox/QSTFST/qstpopmerge/")
MarkerInfo <- read.csv("geno.csv")
TraitInfo <- read.csv("qstmerge_unbal.csv")
rite.csv(finalset.na, "finalset_na.csv")
#########################################################
#### BoxCox transformations
box <- TraitInfo[1:10]
head(box)
# tmp <- boxcox(box$Corollawidth ~ box$dam)
# lam <- tmp$x[max(tmp$y)==tmp$y]
# new <- box$Corollawidth^lam
par(mfrow=c(2,4))
funbox <- function(trait, dam){
tmp <- boxcox(trait ~ dam)
lam <- tmp$x[max(tmp$y)==tmp$y]
return(lam)
}
lamda <- as.vector(apply(box[3:10], 2, funbox, dam=box$dam))
lamda[3]
head(box)
b1 <- box$Corollawidth^lamda[1]
b2 <- box$Corollalength^lamda[2]
b3 <- box$Petallength^lamda[3]
b4 <- box$color492^lamda[4]
b5 <- box$nectaramt^lamda[5]
b6 <- box$nectarconc^lamda[6]
b7 <- box$Root^lamda[7]
b8 <- box$fdate^lamda[8]
all.box <- cbind(box[,1:2], b1, b2, b3, b4, b5, b6, b7, b8)
par(mfrow=c(2,4))
apply(all.box[3:10], 2, hist)
all.box1 <- scale(all.box[3:10])
box.scale <- cbind(all.box[1:2], all.box1)
names(box.scale) <- names(box)
par(mfrow=c(2,4))
apply(box.scale[3:10], 2, hist)
apply(box.scale[3:10], 2, qqnorm)
box.scale.na <- na.exclude(box.scale)
## save files
write.csv(box.scale, "box.scale.csv")
write.csv(box.scale.na, "box.scale.na.csv")
box.scale.na <- read.csv("box.scale.na.csv")
box.scale <- read.csv("box.scale.csv")
names(box.scale.na) <- c("id","pop","dam","Corollawidth","Corollalength","Petallength",
"color492","nectaramt","nectarconc","Root","fdate")
names(box.scale) <- c("id","pop","dam","Corollawidth","Corollalength","Petallength",
"color492","nectaramt","nectarconc","Root","fdate")
#########################################################
#### Scatterplot matrix, correlations and PCA
### Scatterplot matrix
# pairs.panels(raw.na[3:10], pch=20, cex = 1)
pairs.panels(box.scale.na[4:11], pch=20, cex = 1)
# ### Sort by highest correlation
# # function from http://little-book-of-r-for-multivariate-analysis.readthedocs.org/en/latest/src/multivariateanalysis.html
# mosthighlycorrelated <- function(myda
setwd("~/Dropbox/QSTFST/qstpopmerge/")
# library(expm) # for covariance matrix decomposition
library(KernSmooth) # for package neutrality test.r
library(corpcor) # for package neutrality test.r
library(MASS) # for package neutrality test.r
source("~/Dropbox/QSTFST/qstpopmerge/package neutrality test.r")
box.scale.na <- read.csv("box.scale.na.csv")
box.scale <- read.csv("box.scale.csv")
names(box.scale.na) <- c("Id", "Pop", "Dam", "CorollaWidth", "CorollaLength", "PetalLength",
"Color", "NectarAmt", "NectarConc", "Root", "Fdate")
names(box.scale) <- c("Id","Pop","Dam","CorollaWidth","CorollaLength","PetalLength",
"Color","NectarAmt","NectarConc","Root","Fdate")
dam.mean <- aggregate(box.scale[,4:9], list(box.scale$Dam), mean, na.rm=T)
dam.mean
pop.dam <- unique(box.scale[,c(2,3)])
trait.mean <- merge(pop.dam, dam.mean, by.y="Group.1", by.x="Dam")
write.csv(trait.mean, "trait.mean.csv")
tm <- read.csv("trait.mean.csv")
head(tm)
# data <- as.matrix(tm[,4:9])
# factor <- as.matrix(tm[,3])
#######testing
head(tm)
test.data <- cbind(tm$X, tm$Pop, tm$Dam, tm[,4:9])
head(test.data)
names(test.data)
names(test.data) <- c("id", "pop","fam","CorW","CorL","PetL","Col","NecA","NecC")
head(test.data)
## for test.data
n=dim(test.data)[2]-3;nn=table(test.data$pop);nbpop=length(nn);
traits=names(test.data[-c(1:3)]);
effect=paste(traits,collapse=",")
form=as.formula(paste("cbind(",effect,")~factor(pop)",sep="")) #automated formula for the manova
manov=summary(manova(form,data=test.data))                   #do the manova
SSb=manov$SS$"factor(pop)";                             #between pop Sum Squares (SS)
SSw=manov$SS$Residuals;                                 #within pop SS
dfb=manov$stats[1,1];dfw=manov$stats[2,1];              #df between/within pops
nf=mean(nn)-1/nbpop*((mean(nn^2)-mean(nn)^2)/mean(nn)); #compute the equivalent df with unbalanced designs
MSw=SSw/dfw;MSb=SSb/dfb;                                #compute the corresponding Mean Square matrices
Gw=MSw;Gb=(MSb-Gw)/nf;                                  #compute the corresponding G matrices
DF=c(dfw,dfb);G=list(Gw,Gb);MS=list(MSw,MSb);           #create the inputs for k.prop()
# half-sib test
Gw4=4*MSw;Gb=(MSb-Gw4)/nf;
DF=c(dfw,dfb);G4=list(Gw4,Gb);MS=list(MSw,MSb);
# Correlations
Gwcor<- cov2cor(Gw)
Gw4cor<- cov2cor(Gw4)
Gbcor<- cov2cor(Gb)
Gwcor
Gw4cor
Gbcor
make.positive.definite <-
function(x, tol=1e-6) {
eig <- eigen(x, symmetric=TRUE)
rtol <- tol * eig$values[1]
if(min(eig$values) < rtol) {
vals <- eig$values
vals[vals < rtol] <- rtol
srev <- eig$vectors %*% (vals * t(eig$vectors))
dimnames(srev) <- dimnames(x)
return(srev)
} else {
return(x)
}
}
nGb <- make.positive.definite(Gb)
# Correlations
Gwcor<- cov2cor(Gw)
Gw4cor<- cov2cor(Gw4)
nGbcor<- cov2cor(nGb)
Gwcor
Gw4cor
nGbcor
## proportionality testing
#rho_st from test between G matrices
testG=k.prop(DF,G)
paste("rho_P (population) =",signif(testG$rho[[2]],2))
print("95% CI for rho_P :");signif(testG$CI[[2]],2)
#half-sib
testG4=k.prop(DF,G4)
paste("rho_P (population) =",signif(testG4$rho[[2]],2))
print("95% CI for rho_P :");signif(testG4$CI[[2]],2)
#p-values from test between MS matrices
testMS=k.prop(DF,MS);
paste("pBartlett=",signif(testMS$pt1,3),"pChiâ‰¤=",signif(testMS$pX,3))
gw.out <- princomp(covmat=Gw)
names(gw.out)
gw.out$loadings
summary(gw.out)
plot(gw.out) #scree plot
gw4.out <- princomp(covmat=Gw4)
names(gw4.out)
gw4.out$loadings
summary(gw4.out)
plot(gw4.out) #scree plot
gb.out <- princomp(covmat=Gb)
names(gb.out)
gb.out$loadings
summary(gb.out)
plot(gb.out) #scree plot
make.positive.definite <-
function(x, tol=1e-6) {
eig <- eigen(x, symmetric=TRUE)
rtol <- tol * eig$values[1]
if(min(eig$values) < rtol) {
vals <- eig$values
vals[vals < rtol] <- rtol
srev <- eig$vectors %*% (vals * t(eig$vectors))
dimnames(srev) <- dimnames(x)
return(srev)
} else {
return(x)
}
}
nGb <- make.positive.definite(Gb)
gb.out <- princomp(covmat=nGb)
names(gb.out)
gb.out$loadings
summary(gb.out)
plot(gb.out) #scree plot
###############
eigen(Gw)
eigen(Gw)$values/sum(eigen(Gw)$values)
cumsum(eigen(Gw)$values/sum(eigen(Gw)$values))
eigen(Gb)
eigen(Gb)$values/sum(eigen(Gb)$values)
cumsum(eigen(Gb)$values/sum(eigen(Gb)$values))
#Gb
# compare loadings by correlation
a <- abs(eigvb[,1])/sum(abs(eigvb[,1]))
b <- abs(eigvw[,1])/sum(abs(eigvw[,1]))
cor(a,b)
plot(a,b)
c <- abs(eigvb[,2])/sum(abs(eigvb[,2]))
d <- abs(eigvw[,2])/sum(abs(eigvw[,2]))
cor(c,d)
plot(c,d)
eig <- eigen(nGb)
eigv <- eig$vectors
abs(eigv[,1])/sum(abs(eigv[,1]))
abs(eigv[,1])/max(abs(eigv[,1]))
cumsum(eig$values/sum(eig$values))
eig$values/sum(eig$values)
#Gw
eig <- eigen(Gw)
eigv <- eig$vectors
abs(eigv[,1])/sum(abs(eigv[,1]))
abs(eigv[,1])/max(abs(eigv[,1]))
cumsum(eig$values/sum(eig$values))
eig$values/sum(eig$values)
eig <- eigen(Gw4)
eigv <- eig$vectors
abs(eigv[,1])/sum(abs(eigv[,1]))
abs(eigv[,1])/max(abs(eigv[,1]))
cumsum(eig$values/sum(eig$values))
eig$values/sum(eig$values)
eigb <- eigen(nGb)
eigvb <- eigb$vectors
abs(eigvb[,1])/sum(abs(eigvb[,1]))
abs(eigvb[,1])/max(abs(eigvb[,1]))
cumsum(eigb$values/sum(eigb$values))
eigb$values/sum(eigb$values)
#Gw
eigw <- eigen(Gw)
eigvw <- eigw$vectors
abs(eigvw[,1])/sum(abs(eigvw[,1]))
abs(eigvw[,1])/max(abs(eigvw[,1]))
cumsum(eigw$values/sum(eigw$values))
eigw$values/sum(eigw$values)
# compare loadings by correlation
a <- abs(eigvb[,1])/sum(abs(eigvb[,1]))
b <- abs(eigvw[,1])/sum(abs(eigvw[,1]))
cor(a,b)
plot(a,b)
c <- abs(eigvb[,2])/sum(abs(eigvb[,2]))
d <- abs(eigvw[,2])/sum(abs(eigvw[,2]))
cor(c,d)
plot(c,d)
plot(a,c)
dataEllipse(b, d)
plot(a,c)
plotcorr(nGbcor)
dataEllipse(test)
corgb <- cor(a,c)
test <- cbind(a,c)
dataEllipse(test)
dataEllipse(b, d)
plotcorr(nGbcor)
plot(a,c, xlim=c(0,1), ylim=c(0,1))
plot(a,c, xlim=c(0,1), ylim=c(0,1), col="red")
plot(a,c, xlim=c(0,1), ylim=c(0,1), col="red", pch=19)
points(b, d, pch=19, col="blue")
a <- (eigvb[,1])/sum((eigvb[,1]))
b <- (eigvw[,1])/sum((eigvw[,1]))
cor(a,b)
plot(a,b)
c <- (eigvb[,2])/sum((eigvb[,2]))
d <- (eigvw[,2])/sum((eigvw[,2]))
cor(c,d)
plot(c,d)
plot(a,c, xlim=c(0,1), ylim=c(0,1), col="red", pch=19)
plot(a,b)
plot(a,c, xlim=c(-3,3), ylim=c(-2,2), col="red", pch=19)
points(b, d, pch=19, col="blue")
dataEllipse(test)
plot(a,c, xlim=c(-3,3), ylim=c(-2,2), col="red", pch=19)
points(b, d, pch=19, col="blue")
dataEllipse(a,c, levels=.95, plot.points=FALSE)
dataEllipse(b,d, levels=.95, plot.points=FALSE, col="blue")
plot(a,c, xlim=c(-6,6), ylim=c(-5,5), col="red", pch=19)
points(b, d, pch=19, col="blue")
dataEllipse(a,c, levels=.95, plot.points=FALSE, col="red")
dataEllipse(b,d, levels=.95, plot.points=FALSE, col="blue")
MSw
SSb
SSw
nn
manov
form
manov$SS
manova(form,data=test.data)
names(manova(form,data=test.data))
str(manova(form,data=test.data))
names(manov)
manov
str(manov)
micro <- cbind(temp, pca1$li$Axis1, pca1$li$Axis2)
pca1 <- dudi.pca(mydata.na, scannf=FALSE,scale=FALSE)
temp<- as.integer(pop(mydata.na))
### Neutral markers
geo <- read.csv("xy.csv")
mydata <- df2genind(MarkerInfo[,2:12], pop=MarkerInfo$pop)
summary(mydata)
mydata@other$xy <- geo
mydata.na <- na.replace(mydata, met=0)
summary(mydata.na)
mydata.na
pca1 <- dudi.pca(mydata.na, scannf=FALSE,scale=FALSE)
temp<- as.integer(pop(mydata.na))
micro <- cbind(temp, pca1$li$Axis1, pca1$li$Axis2)
quant <- cbind(box.scale.na$Pop,pca.x$scores[,1], pca.x$scores[,2])
x <- box.scale.na[4:9]
pca.x <- princomp(x,scale=TRUE, center=TRUE)
quant <- cbind(box.scale.na$Pop,pca.x$scores[,1], pca.x$scores[,2])
quantx <- tapply(quant[,2], quant[,1], mean)
quanty <- tapply(quant[,3], quant[,1], mean)
microx <- tapply(micro[,2], micro[,1], mean)
microy <- tapply(micro[,3], micro[,1], mean)
plot(quantx, quanty, xlim=c(-3, 6), ylim=c(-5.5, 5.5), pch=19, xlab="Principle Component 1",
ylab="Principle Component 2", main="B) Phenotype PCA for Floral Traits")
plot(microx, microy, xlim=c(-4.5,4.5), ylim=c(-5.5, 5.5), pch=19,xlab="Principle Component 1",
ylab="Principle Component 2", main="A) Microsatellite PCA")
dataEllipse(pca1$li$Axis1, pca1$li$Axis2, groups=as.factor(temp), levels=.95,
plot.points=FALSE, col=rep("#d3d3d3",length(fst.col)),
group.label=rep("",length(fst.col)),center.pch=FALSE)
points(microx, microy,pch=19)
plot(quantx, quanty, xlim=c(-3, 6), ylim=c(-5.5, 5.5), pch=19, xlab="Principle Component 1",
ylab="Principle Component 2", main="B) Phenotype PCA for Floral Traits")
dataEllipse(pca.x$scores[,1], pca.x$scores[,2], groups=as.factor(box.scale.na$Pop),
levels=.95, plot.points=FALSE, center.pch=FALSE,
col=rep("#d3d3d3",length(qst.col)), group.label=rep("",length(qst.col)))
points(quantx, quanty,pch=19)
qpops.code <- c("WCC","BLY","BLH","COI","CUC","NOE",
"H86","GDR","R72","CAR","SPC","LFC","MRS",
"WKP","RVR","H105","GTN")
qst.col <- c("#C7D34F","#CA53D5","#D65033","#89C9CA","#56335B","#587C3D","#CB98C0",
"#C6AB8E","#7B4627","#796ECD","#83D598","#CF9A3F","#C84792","#3F4239",
"#6BD249","#B84B5C","#6286AE")
fpops.code <- c("EBY",  "BLY",  "BLH",  "COI",  "CUC", "ELB",	"FOX",	"GDR",	"LAV",	"MOS",	"NFK",
"PVR",	"R72",	"RVR", "SPC","SFR",	"LFC",	"MRS",	"SCR","NLV",	"WNR",	"WKP")
fst.col <- c("#404520",  "#BF5BD5",  "#68DA48",	"#DA485A",	"#77A8D0",	"#D1A540",
"#623C72",	"#CCC79E",	"#649036",	"#C94B92",	"#C07C7E",	"#6C75CC",
"#7ED992",	"#C9DA4E",	"#7AD2CA",	"#506372",	"#D45728",	"#7C2B2C",
"#412833",	"#5F8565",	"#D0A9CB",	"#A36E3D")
par(mfrow = c(1,2))
par(mar=c(5,5,4,2), oma=c(0,0,0,0))
plot(microx, microy, xlim=c(-4.5,4.5), ylim=c(-5.5, 5.5), pch=19,xlab="Principle Component 1",
ylab="Principle Component 2", main="A) Microsatellite PCA")
dataEllipse(pca1$li$Axis1, pca1$li$Axis2, groups=as.factor(temp), levels=.95,
plot.points=FALSE, col=rep("#d3d3d3",length(fst.col)),
group.label=rep("",length(fst.col)),center.pch=FALSE)
points(microx, microy,pch=19)
plot(quantx, quanty, xlim=c(-3, 6), ylim=c(-5.5, 5.5), pch=19, xlab="Principle Component 1",
ylab="Principle Component 2", main="B) Phenotype PCA for Floral Traits")
dataEllipse(pca.x$scores[,1], pca.x$scores[,2], groups=as.factor(box.scale.na$Pop),
levels=.95, plot.points=FALSE, center.pch=FALSE,
col=rep("#d3d3d3",length(qst.col)), group.label=rep("",length(qst.col)))
points(quantx, quanty,pch=19)
